# [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

子数组大小 至少为 2 ，且
子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。

如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。

示例 1：

```
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
```


示例 2：

```
输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
```


示例 3：

```
输入：nums = [23,2,6,4,7], k = 13
输出：false
```




提示：

```
1 <= nums.length <= 105
0 <= nums[i] <= 109
0 <= sum(nums[i]) <= 231 - 1
1 <= k <= 231 - 1
```

## 方法一：前缀和 + 哈希表

对于连续子序列的和，首先想到的就是前缀和；

则从下标0开始的子序列的和就表示为sum[i], 而如果时从下标i->j之间，我们可以用sum[j] - sum[i-1]（i>时）表示;

那么对于(sum[j] - sum[i-1] ) % k 的结果为0， 需要 sum[j] % k 和 sum[i-1] % k 的值相同，故可以考虑通过哈希表来存储这个值，这样就不需要去计算相减；只需要检查哈希表里这个取模的值是否存在，如果存在，则表示存在子序列的和是k的倍数；否则，将取模的值插入哈希表；

算法流程：

1. 判空；
2. 初始化哈希表，设置 {0: -1}, 表示取模后为0 的索引为 -1；主要是为了处理从头开始的子序列和是k的倍数
3. 初始化前缀和sum；
4. 遍历数组：
   1. 计算前缀和；
   2. 计算取模值；
   3. 判断该值是否在哈希表中：
      1. 若存在，判断当前索引与哈希表索引差值是否>=2;若是，直接返回true（题目要求子序列至少两个元素）
      2. 若不存在，将取模值(键)和当前索引(值)插入哈希表
5. 返回false

复杂度：

- 时间：O(N),只需要遍历一次数组，每次遍历内是O(1)
- 空间：O(N)，需要一个哈希表；

```go
func checkSubarraySum(nums []int, k int) bool {
	l := len(nums)
	if l == 0 || k == 0 {
		return false
	}

	m := map[int]int{0: -1}
	sum := 0
	for i,v := range nums {
		sum += v
		mod := sum % k
		if index, ok := m[mod]; ok {
			if i-index >= 2 {
				return true
			}
		} else {
			m[mod] = i
		}
	}

	return false
}
```



